package com.example.Chess.Game.ChessBoard;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import com.example.Chess.Game.Move.Move;
import com.example.Chess.Game.Move.MoveType;
import com.example.Chess.Game.Pieces.Bishop;
import com.example.Chess.Game.Pieces.King;
import com.example.Chess.Game.Pieces.Knight;
import com.example.Chess.Game.Pieces.Pawn;
import com.example.Chess.Game.Pieces.Piece;
import com.example.Chess.Game.Pieces.PieceType;
import com.example.Chess.Game.Pieces.Queen;
import com.example.Chess.Game.Pieces.Rook;

import lombok.Data;

@Data
public class Board {
   // board hashmap stores the chess board by representing keys as the coordinates of
   // each square on the board and the value as a piece if that square is filled by some piece
   // board hashmap stores the chess board by representing keys as the coordinates of
   // each square on the board and the value as a piece if that square is filled by some piece.
   private HashMap<String, Piece> board = new HashMap<String, Piece>();
   private boolean whiteTurn = true;
   // player1 is white and player2 is black
   private String player1 = null;
   private String player2 = null;
   private King whiteKing;
   private King blackKing;
   private GameState state = GameState.ONGOING;
   private int numMovesMade = 0;

   public Board() { }

   public Board(String player1, String player2) {
      this.player1 = player1;
      this.player2 = player2;
   }

   /**
    * Creates the chessboard with all pieces set in its initial position and
    * adds this to the board hash map.
    */
   public void initBoard() {
      for (int i = 0; i < 8; i++) {
         for (int j = 0; j < 8; j++) {
            int[] pos = {j, i};
            if (i == 1) {
               this.board.put(j + "," + i, new Pawn(pos, false));
            }
            else if (i == 6) {
               this.board.put(j + "," + i, new Pawn(pos, true));
            }
            else if (j == 0 || j == 7) {
               if (i == 7)
                  this.board.put(j + "," + i, new Rook(pos, true));
               else if (i == 0)
                  this.board.put(j + "," + i, new Rook(pos, false));
               else
                  this.board.put(j + "," + i, null);
            }
            else if (j == 1 || j == 6) {
               if (i == 7)
                  this.board.put(j + "," + i, new Knight(pos, true));
               else if (i == 0)
                  this.board.put(j + "," + i, new Knight(pos, false));
               else
                  this.board.put(j + "," + i, null);
            }
            else if (j == 2 || j == 5) {
               if (i == 7)
                  this.board.put(j + "," + i, new Bishop(pos, true));
               else if (i == 0)
                  this.board.put(j + "," + i, new Bishop(pos, false));
               else
                  this.board.put(j + "," + i, null);
            }
            else if (j == 3) {
               if (i == 7)
                  this.board.put(j + "," + i, new Queen(pos, true));
               else if (i == 0)
                  this.board.put(j + "," + i, new Queen(pos, false));
               else
                  this.board.put(j + "," + i, null);
            }
            else if (j == 4) {
               if (i == 7) {
                  this.whiteKing = new King(pos, true);
                  this.board.put(j + "," + i, this.whiteKing);
               }
               else if (i == 0) {
                  this.blackKing = new King(pos, false);
                  this.board.put(j + "," + i, this.blackKing);
               }
               else {
                  this.board.put(j + "," + i, null);
               }
            }
            else {
               this.board.put(j + "," + i, null);
            }
         }
      }

      this.generateMoves();
   }

   /**
    * Checks if a move made given the current state of the board is valid. That is
    * is a move that has been generated by the generateMoves method.
    * @param move a move made on the chess board to be validated.
    * @return true if the move is valid and false if it is not valid.
    */
   public boolean isValidMove(Move move) {
      Piece piece = this.board.get(move.getPrevPos()[0] + "," + move.getPrevPos()[1]);
      if (piece != null) {
         if (piece.isWhite() == this.whiteTurn) {
            for (Move possMove: piece.getMoves()) {
               if (possMove.isSameMove(move)) {
                  return true;
               }
            }
         }
      }
      return false;
   }

   /**
    * static method which applies the supplied move made and changes the board object.
    * @param chessBoard the board which the move should apply to.
    * @param move to be applied.
    */
   public static void applyMove(HashMap<String, Piece> chessBoard, Move move) {
      Piece piece = chessBoard.get(move.getPrevPos()[0] + "," + move.getPrevPos()[1]);
      piece.applyMove(chessBoard, move);
   }

   /**
    * Checks if a move made, which must be of a castle type, given the current
    * state of the board. Used when generating a possible move for the king.
    * @param move to be verified.
    * @return true if the move is valid and false if it is invalid.
    */
   public boolean isValidCastle(Move move) {
      for (int i = 0; i < 8; i++) {
         for (int j = 0; j < 8; j++) {
            Piece piece = this.board.get(j + "," + i);
            if (piece != null) {
               if (piece.isWhite() == !this.whiteTurn) {
                  List<Move> moves = piece.generateMoves(this.board);
                  for (Move opponMove: moves) {
                     int[] attackPos = opponMove.getAffectPos();
                     // checks if an opponent piece is attacking one of the squares the
                     // king is going to castle to.
                     if (move.getMoveType() == MoveType.LEFT_CASTLE) {
                        if (attackPos[0] == 1 || attackPos[0] == 2 || attackPos[0] == 3) {
                           if (attackPos[1] == 7 && this.whiteTurn)
                              return false;
                           else if (attackPos[1] == 0 && !this.whiteTurn)
                              return false;
                        }
                     }
                     else if (move.getMoveType() == MoveType.RIGHT_CASTLE) {
                        if (attackPos[0] == 5 || attackPos[0] == 6) {
                           if (attackPos[1] == 7 && this.whiteTurn)
                              return false;
                           else if (attackPos[1] == 0 && !this.whiteTurn)
                              return false;
                        }
                     }
                  }
               }
            }
         }
      }
      return true;
   }

   /**
    * Checks if a move which could be made by a piece is valid. This is done by checking
    * if the move made will leave the king vulnerable to attack by an opponent piece. In
    * chess it is forbidden for any move that leaves the player's king to be attacked by
    * a piece by the opponent.
    * @param move to be verified.
    * @return true if the move made is valid and false if invalid.
    */
   public boolean isValidPossibleMove(Move move) {
      HashMap<String, Piece> boardCopy = new HashMap<String, Piece>(this.board);
      String prevPos = move.getPrevPos()[0] + "," + move.getPrevPos()[1]; 

      // generate a shallow copy of the board hash map and apply the supplied move to the board.
      Piece copy = Piece.copyPiece(boardCopy, prevPos);
      
      // alongside moving the king, move the rook if the supplied move is a castle
      if (copy.getType() == PieceType.KING && (move.getMoveType() == MoveType.LEFT_CASTLE || move.getMoveType() == MoveType.RIGHT_CASTLE)) {
         String rookPos = move.getAffectPos()[0] + "," + move.getAffectPos()[1];
         Piece rookCopy = Piece.copyPiece(boardCopy, rookPos);
         boardCopy.put(rookPos, rookCopy);
      }

      boardCopy.put(prevPos, copy);
      
      Board.applyMove(boardCopy, move);

      // Obtain the king on the same side of the player whose turn it is to go.
      King king = null;
      for (int i = 0; i < 8; i++) {
         for (int j = 0; j < 8; j++) {
            Piece piece = boardCopy.get(j + "," + i);
            if (piece != null) {
               if (piece.isWhite() == this.whiteTurn && piece.getType() == PieceType.KING) {
                  king = (King) piece;
                  break;
               }
            }
         }
      }
      
      // iterate through all opponent pieces on the board and check no pieces attacking
      // the above king in the copied board.
      for (int i = 0; i < 8; i++) {
         for (int j = 0; j < 8; j++) {
            Piece piece = boardCopy.get(j + "," + i);
            if (piece != null) {
               if (piece.isWhite() == !this.whiteTurn) {
                  List<Move> moves = piece.generateMoves(boardCopy);
                  for (Move opponMove: moves) {
                     int[] attackPos = opponMove.getAffectPos();
                     if (king.getPosition()[0] == attackPos[0] && king.getPosition()[1] == attackPos[1]) {
                        return false;
                     }
                  }
               }
            }
         }
      }

      return true;
   }

   /**
    * Generates all moves that each piece on the same side as the player whose
    * turn it is to play, can be made according to chess rules.
    */
   public void generateMoves() {
      for (int i = 0; i < 8; i++) {
         for (int j = 0; j < 8; j++) {
            Piece piece = this.board.get(j + "," + i);
            if (piece != null) {
               if (piece.isWhite() == this.whiteTurn) {
                  List<Move> moves = piece.generateMoves(this.board);
                  List<Move> validMoves = new ArrayList<Move>();
                  
                  // each piece first generates the moves that it can make on the board
                  // then it is checked whether or not each move generated by the piece
                  // leaves the king open to attack. if it does not, then the move is then
                  // added to the piece's list of moves it can make.
                  for (Move move: moves) {
                     if (move.getMoveType() == MoveType.LEFT_CASTLE || move.getMoveType() == MoveType.RIGHT_CASTLE) {
                        if (this.isValidCastle(move)) {
                           validMoves.add(move);
                        }
                     }
                     else if (this.isValidPossibleMove(move)) {
                        validMoves.add(move);
                     }
                  }

                  if (piece.getType() == PieceType.PAWN) {
                     Pawn pawn = (Pawn) piece;
                     List<Move> enPassantMoves = pawn.getEnPassant(this);
                     for (Move move: enPassantMoves) {
                        if (this.isValidPossibleMove(move)) {
                           validMoves.add(move);
                        }
                     }
                  }

                  piece.setMoves(validMoves);
               }
            }
         }
      }
   }

   /**
    * Check if the black king is being checked by a white piece.
    * @return true if the black king is being checked and false if not.
    */
   public boolean blackKingChecked() {
      for (int i = 0; i < 8; i++) {
         for (int j = 0; j < 8; j++) {
            Piece piece = this.board.get(j + "," + i);
            if (piece != null) {
               if (piece.isWhite() == !this.whiteTurn) {
                  List<Move> moves = piece.generateMoves(this.board);
                  for (Move opponMove: moves) {
                     int[] attackPos = opponMove.getAffectPos();
                     if (this.blackKing.getPosition()[0] == attackPos[0] && this.blackKing.getPosition()[1] == attackPos[1]) {
                        return true;
                     }
                  }
               }
            }
         }
      }
      return false;
   }

   /**
    * Checks if the white king is being checked by a black piece.
    * @return true if the white king is being checked and false if not.
    */
   public boolean whiteKingChecked() {
      for (int i = 0; i < 8; i++) {
         for (int j = 0; j < 8; j++) {
            Piece piece = this.board.get(j + "," + i);
            if (piece != null) {
               if (piece.isWhite() == !this.whiteTurn) {
                  List<Move> moves = piece.generateMoves(this.board);
                  for (Move opponMove: moves) {
                     int[] attackPos = opponMove.getAffectPos();
                     if (this.whiteKing.getPosition()[0] == attackPos[0] && this.whiteKing.getPosition()[1] == attackPos[1]) {
                        return true;
                     }
                  }
               }
            }
         }
      }
      return false;
   }

   /**
    * Checks if the white king has been checkmated.
    * @return true if white king is checkmated and false if not.
    */
   public boolean whiteKingCheckmated() {
      if (this.whiteTurn) {
         if (this.whiteKing.isChecked()) {
            for (int i = 0; i < 8; i++) {
               for (int j = 0; j < 8; j++) {
                  Piece piece = this.board.get(j + "," + i);
                  if (piece != null) {
                     if (piece.isWhite()) {
                        if (piece.getMoves().size() != 0) {
                           return false;
                        }
                     }
                  }
               }
            }
            return true;
         }
      }
      return false;
   }
   
   /**
    * Checks if the black king has been checkmated.
    * @return true if black king is checkmated and false if not.
    */
   public boolean blackKingCheckmated() {
      if (!this.whiteTurn) {
         if (this.blackKing.isChecked()) {
            for (int i = 0; i < 8; i++) {
               for (int j = 0; j < 8; j++) {
                  Piece piece = this.board.get(j + "," + i);
                  if (piece != null) {
                     if (!piece.isWhite()) {
                        if (piece.getMoves().size() != 0) {
                           return false;
                        }
                     }
                  }
               }
            }
            return true;
         }
      }
      return false;
   }

   /**
    * Check if the game has been drawn. This occurs if one side has no
    * valid moves it can play but its king has not been checkmated.
    * @return true if the game has been drawn or false if not.
    */
   public boolean isDraw() {
      if (this.whiteTurn) {
         if (!this.whiteKing.isChecked()) {
            for (int i = 0; i < 8; i++) {
               for (int j = 0; j < 8; j++) {
                  Piece piece = this.board.get(j + "," + i);
                  if (piece != null) {
                     if (piece.isWhite()) {
                        if (piece.getMoves().size() != 0) {
                           return false;
                        }
                     }
                  }
               }
            }
            return true;
         }
         return false;
      }
      else {
         if (!this.blackKing.isChecked()) {
            for (int i = 0; i < 8; i++) {
               for (int j = 0; j < 8; j++) {
                  Piece piece = this.board.get(j + "," + i);
                  if (piece != null) {
                     if (!piece.isWhite()) {
                        if (piece.getMoves().size() != 0) {
                           return false;
                        }
                     }
                  }
               }
            }
            return true;
         }
         return false;
      }
   }

   /**
    * When a player wishes to make a move on the board this function is
    * called and applies that move on the board as long as the move is valid.
    * @param move to be applied to the board.
    */
   public void movePiece(Move move) {
      if (this.getState() == GameState.ONGOING) {
         if (this.isValidMove(move)) {
            // documents what (num)th move the supplied move is within the game.
            this.numMovesMade++;
            move.setMoveNum(this.numMovesMade);
   
            Board.applyMove(this.board, move);
            
            this.whiteTurn = !this.whiteTurn;
         
            if (this.whiteTurn) {
               this.whiteKing.setChecked(this.whiteKingChecked());
            }
            else {
               this.blackKing.setChecked(this.blackKingChecked());
            }
   
            this.generateMoves();
            
            if (this.whiteKingCheckmated()) {
               this.state = GameState.BLACKWIN;
            }
            else if (this.blackKingCheckmated()) {
               this.state = GameState.WHITEWIN;
            }
            else if (this.isDraw()) {
               this.state = GameState.DRAW;
            }
         }
      }
   }
}